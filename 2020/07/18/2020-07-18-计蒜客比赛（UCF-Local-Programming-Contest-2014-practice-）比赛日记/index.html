<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>2020/07/18 计蒜客比赛（UCF Local Programming Contest 2014(practice)）比赛日记 | Nkus1mple's world</title><meta name="description" content="比赛结果5小时的比赛，2小时ak，还是很爽的，不过大概也是因为这次比赛题目都比较水，数据范围不大，暴力好想吧。    解题报告A. How Sweet It is! Background:Dr. Orooji’s twins, Mack and Zack, love video games. We will assume that all games are 50. M&#x2F;Z save all th"><meta name="keywords" content="acm"><meta name="author" content="Nkus1mple"><meta name="copyright" content="Nkus1mple"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/07/18/2020-07-18-%E8%AE%A1%E8%92%9C%E5%AE%A2%E6%AF%94%E8%B5%9B%EF%BC%88UCF-Local-Programming-Contest-2014-practice-%EF%BC%89%E6%AF%94%E8%B5%9B%E6%97%A5%E8%AE%B0/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="2020/07/18 计蒜客比赛（UCF Local Programming Contest 2014(practice)）比赛日记"><meta property="og:url" content="http://yoursite.com/2020/07/18/2020-07-18-%E8%AE%A1%E8%92%9C%E5%AE%A2%E6%AF%94%E8%B5%9B%EF%BC%88UCF-Local-Programming-Contest-2014-practice-%EF%BC%89%E6%AF%94%E8%B5%9B%E6%97%A5%E8%AE%B0/"><meta property="og:site_name" content="Nkus1mple's world"><meta property="og:description" content="比赛结果5小时的比赛，2小时ak，还是很爽的，不过大概也是因为这次比赛题目都比较水，数据范围不大，暴力好想吧。    解题报告A. How Sweet It is! Background:Dr. Orooji’s twins, Mack and Zack, love video games. We will assume that all games are 50. M&#x2F;Z save all th"><meta property="og:image" content="https://s1.ax1x.com/2020/07/14/Ua8Lyd.md.jpg"><meta property="article:published_time" content="2020-07-18T06:12:10.000Z"><meta property="article:modified_time" content="2020-07-18T08:00:03.610Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="next" title="Read Me" href="http://yoursite.com/2020/07/14/Read-Me/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-link"></i><span> Messageboard</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#比赛结果"><span class="toc-number">1.</span> <span class="toc-text">比赛结果</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解题报告"><span class="toc-number">2.</span> <span class="toc-text">解题报告</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-How-Sweet-It-is"><span class="toc-number">2.1.</span> <span class="toc-text">A. How Sweet It is!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-Wheel-of-Universally-Copious-Fortune"><span class="toc-number">2.2.</span> <span class="toc-text">B. Wheel of Universally Copious Fortune</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-Positively-Pentastic"><span class="toc-number">2.3.</span> <span class="toc-text">C. Positively Pentastic!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#D-Lottery-Coprimes"><span class="toc-number">2.4.</span> <span class="toc-text">D. Lottery Coprimes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#E-Pac-Man-for-your-New-Phone"><span class="toc-number">2.5.</span> <span class="toc-text">E. Pac Man for your New Phone</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#F-Sierpinski-Triangle"><span class="toc-number">2.6.</span> <span class="toc-text">F. Sierpinski Triangle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G-Walking-in-the-Sun"><span class="toc-number">2.7.</span> <span class="toc-text">G. Walking in the Sun</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H-Tautobots-and-Contradicticons"><span class="toc-number">2.8.</span> <span class="toc-text">H. Tautobots and Contradicticons</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-A-Constant-Struggle"><span class="toc-number">2.9.</span> <span class="toc-text">I. A Constant Struggle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#J-Polygon-Restoration"><span class="toc-number">2.10.</span> <span class="toc-text">J. Polygon Restoration</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li></ol></div></div></div><div class="code-close" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s1.ax1x.com/2020/07/14/Ua8Lyd.md.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Nkus1mple's world</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-link"></i><span> Messageboard</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">2020/07/18 计蒜客比赛（UCF Local Programming Contest 2014(practice)）比赛日记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-18 14:12:10"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-18</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-18 16:00:03"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-18</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="比赛结果"><a href="#比赛结果" class="headerlink" title="比赛结果"></a>比赛结果</h1><p>5小时的比赛，2小时ak，还是很爽的，不过大概也是因为这次比赛题目都比较水，数据范围不大，暴力好想吧。 </p>
<p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/18/Uged0J.png" alt="" title="ak完截图留念 排名为比赛过程中排名 非最终排名。"> </p>
<h1 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h1><h2 id="A-How-Sweet-It-is"><a href="#A-How-Sweet-It-is" class="headerlink" title="A. How Sweet It is!"></a>A. How Sweet It is!</h2><blockquote>
<p><strong>Background:</strong><br>Dr. Orooji’s twins, Mack and Zack, love video games. We will assume that all games are 50. M/Z save all the money they get and, when they have 50. M/Z save all the money they get and, when they have 50 or more, they buy a game and say “Sweet!” out of happiness. If M/Z get a large amount of money at one time (e.g., on their birthday) and they can buy two or more games, they buy two or more games (as many as they can) and say “Totally Sweet!” since they are really in heaven! When M/Z buy game(s), they save the left-over money towards the next purchase.<br><strong>The Problem:</strong><br>Given the money (various amounts) M/Z receive, you are to write a program to tell Dr. O when Sweet or Totally Sweet is coming.<br><strong>The Input:</strong><br>Each input line contains a positive integer, indicating an amount M/Z are receiving. End-of-data is indicated with a zero.<br><strong>The Output:</strong><br>Print the input line numbers and the messages they generate. Follow the format illustrated in Sample Output.<br><strong>样例输入</strong><br>10<br>20<br>30<br>10<br>90<br>10<br>10<br>30<br>0<br><strong>样例输出</strong><br>Input #3: Sweet!<br>Input #5: Totally Sweet!<br>Input #8: Sweet!  </p>
</blockquote>
<p><strong>题意</strong>：不断获得钱，够50就买糖，够买多少买多少，买一颗糖输出”Sweet”，买两颗及以上输出”Totally Sweet!”<br><strong>题解</strong>：签到模拟。<br><strong>代码</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	int sum&#x3D;0;</span><br><span class="line">	int cnt&#x3D;1,left&#x3D;0,time&#x3D;0;</span><br><span class="line">	while(n!&#x3D;0)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+&#x3D;n;</span><br><span class="line">		time&#x3D;sum&#x2F;50;</span><br><span class="line">		if(time&#x3D;&#x3D;1)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;&quot;Input #&quot;&lt;&lt;cnt&lt;&lt;&quot;: &quot;&lt;&lt;&quot;Sweet!&quot;&lt;&lt;endl;</span><br><span class="line">			sum-&#x3D;50;</span><br><span class="line">		&#125;</span><br><span class="line">		if(time&gt;&#x3D;2)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;&quot;Input #&quot;&lt;&lt;cnt&lt;&lt;&quot;: &quot;&lt;&lt;&quot;Totally Sweet!&quot;&lt;&lt;endl;</span><br><span class="line">			sum%&#x3D;50;</span><br><span class="line">		&#125;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;by electronic or perfecto?</span><br></pre></td></tr></table></figure>
<h2 id="B-Wheel-of-Universally-Copious-Fortune"><a href="#B-Wheel-of-Universally-Copious-Fortune" class="headerlink" title="B. Wheel of Universally Copious Fortune"></a>B. Wheel of Universally Copious Fortune</h2><blockquote>
<p><strong>Background:</strong><br>In the game “Wheel of Fortune”, the number of letters in a word is given and the contestants guess the letters in the word and, as some letters appear, the contestants guess the word. But, you are a computer scientist and know that you can write a program to search a dictionary and provide candidate words (possible matches) for you.<br><strong>The Problem:</strong><br>Given the dictionary and a partially-defined word, you are to determine the candidate words. Note that there may be no candidate words for a given partially-defined word.<br><strong>The Input:</strong><br>The first input line contains an integer n (1 ≤ n ≤ 100), indicating the number of words in the dictionary. The dictionary words will be on the following n input lines, one word per line. Each word starts in column 1, contains only lowercase letters, and will be 1-20 letters (inclusive).   Assume that the dictionary words are distinct, i.e., no duplicates. The next input line will contain a positive integer m, indicating the number of words to be checked against the dictionary. These words will be on the following m input lines, one word per line. Each word starts in column 1, contains only lowercase letters and hyphens, and will be 1-20 characters (inclusive). A letter in a position indicates that the word must have that letter in that position; a hyphen in a position indicates that any letter can be in that position.<br><strong>The Output:</strong><br>At the beginning of each word to be checked, output “Word #w:”, where w is the word number (starting from 1). Then print the input word to be checked. Then, on the following output lines, print the candidate words from dictionary that could be a match (print these words in the order they appear in the dictionary). Also print the total number of candidate words (possible matches).<br>Leave a blank line after the output for each test case. Follow the format illustrated in Sample Output.<br><strong>样例输入</strong><br>8<br>at<br>cat<br>ali<br>sat<br>nerds<br>coach<br>couch<br>ninja<br>5<br>co-ch<br>-at<br><code>---</code><br>ali<br>a-c<br><strong>样例输出</strong><br>Word #1: co-ch<br>coach<br>couch<br>Total number of candidate words = 2<br>Word #2: -at<br>cat<br>sat<br>Total number of candidate words = 2<br>Word #3: —<br>cat<br>ali<br>sat<br>Total number of candidate words = 3<br>Word #4: ali<br>ali<br>Total number of candidate words = 1<br>Word #5: a-c<br>Total number of candidate words = 0<br>(空行已省略)</p>
</blockquote>
<p><strong>题意</strong>：给定字典，给定要匹配的字符串，字符’-‘代表可以任意匹配字典中的字符，问给出的字符串能匹配多少字典中的字符串。<br><strong>题解</strong>：暴力匹配。<br><strong>代码</strong>：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;string&gt;q;</span><br><span class="line">bool cmp(string a,string b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a.length()!&#x3D;b.length())return false;</span><br><span class="line">	for(int i&#x3D;0;i&lt;a.length();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(a[i]!&#x3D;b[i]&amp;&amp;a[i]!&#x3D;&#39;-&#39;)return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string a;</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		q.push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	int mark&#x3D;0;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string s;</span><br><span class="line">		cin&gt;&gt;s;</span><br><span class="line">		vector&lt;int&gt;num;</span><br><span class="line">		if(mark++)cout&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;&quot;Word #&quot;&lt;&lt;i&lt;&lt;&quot;: &quot;&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">		int cnt&#x3D;0;</span><br><span class="line">		for(int j&#x3D;0;j&lt;q.size();j++)</span><br><span class="line">		&#123;	</span><br><span class="line">			string temp&#x3D;q[j];</span><br><span class="line">			if(cmp(s,temp))</span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;q[j]&lt;&lt;endl;</span><br><span class="line">				cnt++;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;&quot;Total number of candidate words &#x3D; &quot;&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;by electronic or perfecto?</span><br></pre></td></tr></table></figure>
<h2 id="C-Positively-Pentastic"><a href="#C-Positively-Pentastic" class="headerlink" title="C. Positively Pentastic!"></a>C. Positively Pentastic!</h2><blockquote>
<p><strong>Background:</strong><br>Five random integers are placed at the corners of a pentagon. Typically, some of these numbers will be negative, but their sum is guaranteed to be positive. The goal is to get rid of all the negative numbers through a balanced process of subtraction and negation.<br>Starting with the lowest of the negative numbers, we negate the number (thus making it positive), and then subtract that value from each of its two neighbors. The sum of the new numbers will remain the same as the original pentagon, so the pentagon is still “balanced.” This process (finding the lowest of the negative numbers, negating it, and subtracting it from its neighbors) is then repeated until all of the numbers are non-negative.image.pngDuring any step, if the lowest negative number appears at more than one corner, use the one that would be found first, if you started at the top corner and traversed in clockwise direction.<br><img src= "/img/loading.gif" data-src="https://res.jisuanke.com/img/upload/f92b2ddf71c99f7961c9767a9d1176737c4e4bbc.png" alt=""><br><strong>The Problem:</strong><br> Given the original five numbers at the corners of a pentagon, output the Positive Pentagon that can be created by following this process. You may assume this process will always make a pentagon “pentastic” in at most 1000 steps.<br><strong>The Input:</strong><br>The first input line will contain only a single positive integer N, which is the number of pentagons to process. The next N lines will contain pentagon descriptions, one per line. Each pentagon description will consist of exactly 5 integers, which are in the range -999 to 999 (inclusive), and which sum up to a positive number less than 1000.<br>There will be exactly one space between numbers, and no leading or trailing spaces on the input lines. Positive numbers in the input will not have a leading ‘+’ sign. The numbers are given in a clockwise order around the pentagon, starting from the top. This means that the 1st and 3rd numbers are neighbors of the 2nd number, the 5th and 2nd numbers are neighbors of the 1st number, and so on.<br><strong>The Output:</strong><br>For each pentagon in the input, output the message “Pentagon #p:”, where p is the pentagon number (starting from 1). Then, for each pentagon, output the Positive Pentagon that results from applying the process described above. Output the numbers for each corner using the same ordering and method used in the input, with number for the top corner first, and the others following a clockwise order. Output one space between output numbers.<br>Leave a blank line after the output for each test case. Follow the format illustrated in the Sample Output.<br><strong>样例输入</strong><br>2<br>2 -1 5 7 -4<br>99 -1 -1 4 0<br><strong>样例输出</strong><br>Pentagon #1:<br>1 2 2 3 1<br>Pentagon #2:<br>97 1 1 2 0<br>（空行已省略）</p>
</blockquote>
<p><strong>题意</strong>：五边形五个数，取最小的负数，使其变成相反数，相邻两数减去这个正数，循环至全部变成非负数为止，求最后的五边形。<br><strong>题解</strong>：模拟。<br><strong>代码</strong>：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int t,a[10];</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	for(int p&#x3D;1;p&lt;&#x3D;t;++p)&#123;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;5;++i)</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">		while(1)&#123;</span><br><span class="line">			int mn(1000),pos(0);</span><br><span class="line">			for(int i&#x3D;1;i&lt;&#x3D;5;++i)</span><br><span class="line">				if(a[i]&lt;mn&amp;&amp;a[i]&lt;0)</span><br><span class="line">					mn&#x3D;a[i],pos&#x3D;i;</span><br><span class="line">			if(!pos)break;</span><br><span class="line">			if(pos&#x3D;&#x3D;1)&#123;</span><br><span class="line">				a[1]&#x3D;-a[1];</span><br><span class="line">				a[2]-&#x3D;a[1];</span><br><span class="line">				a[5]-&#x3D;a[1];</span><br><span class="line">			&#125;</span><br><span class="line">			else if(pos&#x3D;&#x3D;5)&#123;</span><br><span class="line">				a[5]&#x3D;-a[5];</span><br><span class="line">				a[4]-&#x3D;a[5];</span><br><span class="line">				a[1]-&#x3D;a[5];</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				a[pos]&#x3D;-a[pos];</span><br><span class="line">				a[pos-1]-&#x3D;a[pos];</span><br><span class="line">				a[pos+1]-&#x3D;a[pos];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Pentagon #%d:\n&quot;,p);</span><br><span class="line">		printf(&quot;%d&quot;,a[1]);</span><br><span class="line">		for(int i&#x3D;2;i&lt;&#x3D;5;++i)</span><br><span class="line">			printf(&quot; %d&quot;,a[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		if(p!&#x3D;t)printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;by s1mple</span><br></pre></td></tr></table></figure>
<h2 id="D-Lottery-Coprimes"><a href="#D-Lottery-Coprimes" class="headerlink" title="D. Lottery Coprimes"></a>D. Lottery Coprimes</h2><blockquote>
<p><strong>Background:</strong><br>Lou lost the lottery last week, but he still plans to buy a ticket for this week’s draw. He’s also buying tickets for all his relatives. They are all mathematicians (who understand probability) and would never buy tickets for themselves. Lou insisted that they each choose their own numbers. When he looked at the numbers, it appeared as though all of his relatives had played a joke on him. They seemed to choose numbers by picking a pair of coprime integers, concatenating them, then splitting the digits up into the number spots on the lottery ticket.<br>Two integers are called coprimes, or relative primes, if they do not share any positive factors greater than 1. (That’s the joke—they are “relative” primes from his relatives.)<br><img src= "/img/loading.gif" data-src="https://res.jisuanke.com/img/upload/3d87f2ec52dafdcdb0f3c4f617160e52d28c9353.png" alt=""><br>These are the lottery numbers from one of Lou’s math-loving relative’s tickets. The numbers 169 and 7203 are coprime.<br><strong>The Problem:</strong><br>Given a list of concatenated digits from a lottery ticket, determine whether this list can be split into two numbers which are coprimes. Note that the digits can not be reordered.<br><strong>The Input:</strong><br>The first line of input will contain only a single positive integer N, which is the number of lottery tickets to evaluate. Each of the next N input lines will contain 3 to 8 digits, representing a single ticket. Neither the first digit nor the last digit will ever be zero, and there will never be two consecutive zeroes. There will be no spaces or other characters on these lines, other than digits.<br><strong>The Output:</strong><br>For each ticket in the input, output “Ticket #T:”, where T is the ticket number (starting at 1). On the next line, output the two coprimes found by splitting the digits for that ticket. Separate the numbers by at least one space. If no coprimes are found, output the message “Not relative” instead, since the numbers were probably not picked by any of Lou’s relatives. If there are multiple possible ways to split the digits into coprimes, use the one in which the first number is the lowest. If the split occurs before a zero digit, you may omit this leading zero when outputting the second number, i.e., you can output a number with leading zeroes with or without those zeroes.<br>Leave a blank line after the output for each ticket. Follow the format shown in Sample Output.<br><strong>样例输入</strong><br>4<br>47108<br>222<br>1697203<br>7203217<br><strong>样例输出</strong><br>Ticket #1:<br>47 108<br>Ticket #2:<br>Not relative<br>Ticket #3:<br>1 697203<br>Ticket #4:<br>72 3217<br>(空行已省略)</p>
</blockquote>
<p><strong>题意</strong>：把数分成前后两部分，使两部分互质，若有多种分法，则选择前面部分数最小的方案输出。<br><strong>题解</strong>：枚举分隔，求gcd，若为1，输出。<br><strong>代码</strong>：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int N;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Ticket #&quot;&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;endl;</span><br><span class="line">        int num;</span><br><span class="line">        cin&gt;&gt;num;</span><br><span class="line">        int e&#x3D;1,found&#x3D;0;</span><br><span class="line">        while(num%e!&#x3D;num)</span><br><span class="line">        &#123;e*&#x3D;10;&#125;</span><br><span class="line">        while(e&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            int a,b;</span><br><span class="line">            b&#x3D;num%e;</span><br><span class="line">            a&#x3D;(num-b)&#x2F;e;</span><br><span class="line">            e&#x2F;&#x3D;10;</span><br><span class="line">            if(__gcd(a,b)&#x3D;&#x3D;1)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">                found&#x3D;1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!found)</span><br><span class="line">        &#123;cout&lt;&lt;&quot;Not relative&quot;&lt;&lt;endl;&#125;</span><br><span class="line">        if(i&lt;N)</span><br><span class="line">        &#123;cout&lt;&lt;endl;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;by electronic or perfecto</span><br></pre></td></tr></table></figure>
<h2 id="E-Pac-Man-for-your-New-Phone"><a href="#E-Pac-Man-for-your-New-Phone" class="headerlink" title="E. Pac Man for your New Phone"></a>E. Pac Man for your New Phone</h2><blockquote>
<p><strong>Background:</strong><br>You are writing an app for your friend’s new Phone, the newPhone. Since you grew up on Pac Man, you want to write a simplified version of the game. In this game, the board is a rectangular grid and Pac Man starts at the upper left-hand corner. His goal is to get to the lower right-hand corner. He always moves one square to the right or one square down. Each square he goes to has a “goody” that’s worth a particular amount of points. Your score is simply the sum of the scores of the goodies in each square you have visited.<br>For example, if the game board looks like this (P indicates Pac Man’s starting location, and E indicates his ending location):<br><img src= "/img/loading.gif" data-src="https://res.jisuanke.com/img/upload/c33ddb6466a9ca3e705118a2a5f94b178398540f.png" alt=""><br>then Pac Man’s optimal strategy would be to move right, down, right, right again, then down to yield a score of 3 + 4 + 9 + 3 = 19.<br><strong>The Problem:</strong><br>Given a game board, determine the maximum possible score for Pac Man.<br><strong>The Input:</strong><br>There will be multiple game boards in the input file. The first input line contains a positive integer n, indicating the number of game boards to be processed. The first line of each game board will contain two positive integers, r (0 &lt; r &lt; 100) and c (1 &lt; c &lt; 100), representing the number of rows and columns for this game board. (The example above has three rows and four columns.) Each of the following r input lines will contain c tokens, representing the contents of that row. The first item on the first of these lines will be the character ‘P’, representing Pac Man’s original location and the last item on the last line will be the character ‘E’, representing Pac Man’s goal location. The rest of the items will be positive integers less than 1000. Items will be separated by a single space on each line.<br><strong>The Output:</strong><br>At the beginning of each test case, output “Game Board #g:”, where g is the input board number (starting from 1). For each game board, simply print out the maximum possible score for the game.<br>Leave a blank line after the output for each test case. Follow the format illustrated in Sample Output.<br><strong>样例输入</strong><br>2<br>3 4<br>P 3 2 8<br>1 4 9 3<br>6 2 2 E<br>2 2<br>P 5<br>401 E<br><strong>样例输出</strong><br>Game Board #1: 19<br>Game Board #2: 401<br>(空行已省略)</p>
</blockquote>
<p><strong>题意</strong>：吃豆人，以左上角为起点，右下角为终点，只能向右或向下，每个格子都有分数，问到终点最大分数和。<br><strong>题解</strong>：<br>基础DP。<br>设第i行第j列格子分数为a[i][j]，设到该格子的最大分数和为f[i][j]，则有：  </p>
<blockquote>
<p><strong>f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j]</strong>  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int t,r,c,a[105][105],f[105][105];</span><br><span class="line">char tmp;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	for(int p&#x3D;1;p&lt;&#x3D;t;++p)&#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;r,&amp;c);</span><br><span class="line">		cin&gt;&gt;tmp;</span><br><span class="line">		for(int i&#x3D;2;i&lt;&#x3D;c;++i)</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;a[1][i]);</span><br><span class="line">		for(int i&#x3D;2;i&lt;r;++i)</span><br><span class="line">			for(int j&#x3D;1;j&lt;&#x3D;c;++j)</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;a[i][j]);</span><br><span class="line">		for(int i&#x3D;1;i&lt;c;++i)</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;a[r][i]);</span><br><span class="line">		cin&gt;&gt;tmp;</span><br><span class="line">		a[1][1]&#x3D;a[r][c]&#x3D;0;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;r;++i)</span><br><span class="line">			for(int j&#x3D;1;j&lt;&#x3D;c;++j)</span><br><span class="line">				f[i][j]&#x3D;0;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;r;++i)</span><br><span class="line">			for(int j&#x3D;1;j&lt;&#x3D;c;++j)</span><br><span class="line">				f[i][j]&#x3D;max(f[i-1][j],f[i][j-1])+a[i][j];</span><br><span class="line">		printf(&quot;Game Board #%d: %d\n&quot;,p,f[r][c]);</span><br><span class="line">		if(p!&#x3D;t)printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;by s1mple</span><br></pre></td></tr></table></figure>
<h2 id="F-Sierpinski-Triangle"><a href="#F-Sierpinski-Triangle" class="headerlink" title="F. Sierpinski Triangle"></a>F. Sierpinski Triangle</h2><blockquote>
<p><strong>Background:</strong><br>The Sierpinski triangle is a beautiful fractal found in mathematics. As with many fractal patterns, it is constructed by starting with a given shape, applying a function to that shape, then applying the same function to the resulting shapes, and so on. In theory, this function is applied infinitely many times, but in practice it usually stops after a given number of applications since the resulting shapes get too small to be noticeable.<br>The Sierpinski triangle is created with the following steps:  </p>
<ol>
<li>Start with an equilateral triangle with the base parallel to the horizontal axis.   </li>
<li>Create an upside down triangle with half the height and width of the original triangle and cut this pattern out of the center of the original triangle, leaving 3 equilateral triangles.  </li>
<li>Repeat step 2 on each of the newly formed triangles.  </li>
</ol>
</blockquote>
<blockquote>
<p>The following image (from Wikipedia) shows triangles of level 1 through 5, respectively:<br><img src= "/img/loading.gif" data-src="https://res.jisuanke.com/img/upload/90ed362c46aa06c73fbcb60e991f4ec00db9512b.png" alt=""><br>Interestingly enough, there are other shapes to which you can apply a similar pattern that result in close approximations of a Sierpinski triangle. For example, starting with a square, you can remove rectangles of half the height and a quarter of the width from the upper left and right corners, resulting in three new squares. The following image (from Wikipedia) shows approximate triangles of level 1 through 5, respectively:<br><img src= "/img/loading.gif" data-src="https://res.jisuanke.com/img/upload/cbd8c60a6cd63c01c6ce68533d9d649446d50d9e.png" alt=""><br><strong>The Problem:</strong><br>Given a level, draw an ASCII version of the approximate Sierpinski triangle.<br><strong>The Input:</strong><br>The input will begin with a positive integer T representing the number of triangles to draw. This will be followed by T lines each with a positive integer K ≤ 10 representing the level of the triangle you are to draw.<br><strong>The Output:</strong><br>For each triangle, begin with the line “Triangle #S:” with S starting at 1. Then output the ASCII version of the approximate level K triangle, using the character ‘X’ to represent the drawn pattern and spaces elsewhere. You should scale the image so that the smallest square regions are 2x2. The bottom left point of the image should be in column 1. See the sample output for clarification. Follow each triangle with a blank line.<br><strong>样例输入</strong><br>2<br>1<br>4<br><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/18/Ug1gw8.png" alt="">   </p>
</blockquote>
<p><strong>题意</strong>：谢尔宾斯基三角形的变形。<br><strong>题解</strong>：利用之前形成的图形递推地构造即可。<br><strong>代码</strong>：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char txt[11][1025][1025];</span><br><span class="line">int fac[11];</span><br><span class="line">int n,t;</span><br><span class="line">void init()&#123;</span><br><span class="line">	fac[0]&#x3D;1;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;10;++i)</span><br><span class="line">		fac[i]&#x3D;fac[i-1]&lt;&lt;1;</span><br><span class="line">	txt[1][1][1]&#x3D;txt[1][1][2]&#x3D;txt[1][2][1]&#x3D;txt[1][2][2]&#x3D;&#39;X&#39;;</span><br><span class="line">	for(int i&#x3D;2;i&lt;&#x3D;10;++i)&#123;</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;fac[i-1];++j)&#123;</span><br><span class="line">			for(int k&#x3D;1;k&lt;&#x3D;fac[i-2];++k)</span><br><span class="line">				txt[i][j][k]&#x3D;&#39; &#39;;</span><br><span class="line">			for(int k&#x3D;fac[i-2]+1;k&lt;&#x3D;fac[i-1]+fac[i-2];++k)</span><br><span class="line">				txt[i][j][k]&#x3D;txt[i-1][j][k-fac[i-2]];</span><br><span class="line">			for(int k&#x3D;fac[i-1]+fac[i-2]+1;k&lt;&#x3D;fac[i];++k)</span><br><span class="line">				txt[i][j][k]&#x3D;&#39; &#39;;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j&#x3D;fac[i-1]+1;j&lt;&#x3D;fac[i];++j)&#123;</span><br><span class="line">			for(int k&#x3D;1;k&lt;&#x3D;fac[i-1];++k)</span><br><span class="line">				txt[i][j][k]&#x3D;txt[i][j][k+fac[i-1]]&#x3D;txt[i-1][j-fac[i-1]][k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	init();</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	for(int p&#x3D;1;p&lt;&#x3D;t;++p)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		printf(&quot;Triangle #%d:\n&quot;,p);</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;fac[n];++i)&#123;</span><br><span class="line">			for(int j&#x3D;1;j&lt;&#x3D;fac[n];++j)</span><br><span class="line">				putchar(txt[n][i][j]);</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if(p!&#x3D;t)printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;by s1mple</span><br></pre></td></tr></table></figure>
<h2 id="G-Walking-in-the-Sun"><a href="#G-Walking-in-the-Sun" class="headerlink" title="G. Walking in the Sun"></a>G. Walking in the Sun</h2><blockquote>
<p><strong>Background:</strong><br>You have calculated all the shortest distances between points on campus, but have found that this strategy is not optimal in the summer. Some of these shortest paths are in the sun, and it’s far more annoying to be sweating than to walk a few extra steps in the shade. Your goal is to recalculate shortest distances in the sun on campus, given information about where shade is located.<br><img src= "/img/loading.gif" data-src="https://res.jisuanke.com/img/upload/cfa65c89611aed35259cb3570b26598be6390c49.png" alt=""><br><strong>The Problem:</strong><br>We simplify the problem by specifying all locations on campus by 2-D Cartesian coordinates, and by specifying all areas of shade as circular areas with a given center and radius. We also assume that any straight line between two Cartesian points can be walked, i.e., there are no objects blocking any possible straight line paths. Instead of calculating the shortest distance between locations on campus, your goal will be to calculate the least amount of walking that needs to be done in the sun to get between those two points.<br><strong>The Input:</strong><br>There will be multiple test cases in the input file. The first input line contains a positive integer, indicating the number of test cases.<br>The first line of each test case, s (0 ≤ s &lt; 50), contains the number of locations of shade on campus for that test case. Each of the next s lines contains the x-coordinate, y-coordinate, and radius, respectively, of a shade location, separated by spaces.<br>The next line of each test case, q (0 &lt; q &lt; 100), contains the number of distance queries for the test case. Each of the next q lines will contain four numbers representing two points on campus, in the form x1 y1 x2 y2, where (x1,y1) are the coordinates of the first point, and (x2,y2) are the coordinates of the second point.<br>All x-coordinates, y-coordinates, and radii will be real numbers between -1000 and 1000, inclusive.<br><strong>The Output:</strong><br>At the beginning of each test case, output “Campus #c:”, where c is the test case number (starting from 1) on the first line.<br>For the subsequent q lines, begin the output with the header “ Path #p:”, where p is the distance query number (starting from 1) for that case.   Follow each of these headers with the statement of the form: “Shortest sun distance is D.”, where D is the desired shortest sun distance rounded to one decimal place. To clarify “rounded to one decimal place”: the output for 1.74 should be 1.7, for 1.75 should be 1.8, and for 1.76 should be 1.8.<br>Leave a blank line after the output for each test case. Follow the format illustrated in Sample Output.<br><strong>样例输入</strong><br>2<br>3<br>5.2 3.3 4.7<br>-8.8 -6.1 3.1<br>18.5 6.1 2.2<br>6<br>1.1 20.2 6.1 18.1<br>1.1 20.2 3.3 -2.5<br>0.4 -2.7 3.3 -2.5<br>6.1 18.1 -5.5 -9.2<br>3.3 -2.5 0.4 -2.7<br>1.1 20.2 0.4 -2.7<br>1<br>0.0 0.0 20.0<br>1<br>3.1 2.2 7.7 8.1<br><strong>样例输出</strong><br>Campus #1:<br>  Path #1: Shortest sun distance is 5.4.<br>  Path #2: Shortest sun distance is 14.1.<br>  Path #3: Shortest sun distance is 2.9.<br>  Path #4: Shortest sun distance is 20.6.<br>  Path #5: Shortest sun distance is 2.9.<br>  Path #6: Shortest sun distance is 15.7.<br>Campus #2:<br>  Path #1: Shortest sun distance is 0.0.<br>  (空行已省略)<br><strong>样例解释</strong><br>Note: For this problem, There is no extra blank line after the last test case.  </p>
</blockquote>
<p><strong>题意</strong>：在一片空地上，有一些阴影，阴影为圆形，除了阴影覆盖的地方都是太阳晒的区域，给出多组询问，问两点之间被太阳晒的最短的路径长度，答案四舍五入保留一位小数。<br><strong>题解</strong>：问题问的是被太阳晒的最短的路径长度，考虑中间只有一个圆形阴影，那么该长度要么是不经过该圆形阴影区域，要么经过它。而经过该圆形阴影区域，在太阳外晒的路程最短的路径，显然是起点与圆心的连线，圆心与终点的连线。<br>这个结论是显然的。因为一个点到圆周上的最短距离便是沿法线方向进入的。<br>所以我们可以以圆心为点建完全图，边权为两个圆的距离，即：  </p>
<blockquote>
<p><strong>dis[i][j]=max(0,Get_Dis(x[i],y[i],x[j],y[j]))</strong>  </p>
</blockquote>
<p>对于每组询问，只要把起止点加入图中，然后跑Floyd就可以了。<br><strong>代码</strong>：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">double x[55],y[55],r[55],mp[55][55],dis[55][55];</span><br><span class="line">int t,s,q;</span><br><span class="line">double Pow(double x)&#123;</span><br><span class="line">	return x*x;</span><br><span class="line">&#125;</span><br><span class="line">double GetDis(double x1,double y1,double x2,double y2)&#123;</span><br><span class="line">	return sqrt(Pow(x1-x2)+Pow(y1-y2));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	&#x2F;&#x2F;freopen(&quot;G.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	for(int p&#x3D;1;p&lt;&#x3D;t;++p)&#123;</span><br><span class="line">		printf(&quot;Campus #%d:\n&quot;,p);</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;s);</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;s;++i)</span><br><span class="line">			scanf(&quot;%lf%lf%lf&quot;,&amp;x[i],&amp;y[i],&amp;r[i]);</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;s;++i)</span><br><span class="line">			for(int j&#x3D;1;j&lt;&#x3D;s;++j)</span><br><span class="line">				mp[i][j]&#x3D;max((double)0,GetDis(x[i],y[i],x[j],y[j])-r[i]-r[j]);</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">		for(int o&#x3D;1;o&lt;&#x3D;q;++o)&#123;</span><br><span class="line">			scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x[0],&amp;y[0],&amp;x[s+1],&amp;y[s+1]);</span><br><span class="line">			mp[0][s+1]&#x3D;mp[s+1][0]&#x3D;GetDis(x[0],y[0],x[s+1],y[s+1]);</span><br><span class="line">			for(int i&#x3D;1;i&lt;&#x3D;s;++i)</span><br><span class="line">				mp[0][i]&#x3D;mp[i][0]&#x3D;max((double)0,GetDis(x[0],y[0],x[i],y[i])-r[i]),mp[i][s+1]&#x3D;mp[s+1][i]&#x3D;max((double)0,GetDis(x[s+1],y[s+1],x[i],y[i])-r[i]);</span><br><span class="line">			for(int i&#x3D;0;i&lt;&#x3D;s+1;++i)</span><br><span class="line">				for(int j&#x3D;0;j&lt;&#x3D;s+1;++j)</span><br><span class="line">					dis[i][j]&#x3D;mp[i][j];</span><br><span class="line">			for(int k&#x3D;0;k&lt;&#x3D;s+1;++k)</span><br><span class="line">				for(int i&#x3D;0;i&lt;&#x3D;s+1;++i)</span><br><span class="line">					for(int j&#x3D;0;j&lt;&#x3D;s+1;++j)</span><br><span class="line">						dis[i][j]&#x3D;min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">			printf(&quot;  Path #%d: Shortest sun distance is %.1lf.\n&quot;,o,round(dis[0][s+1]*10)&#x2F;10.0);</span><br><span class="line">		&#125;</span><br><span class="line">		if(p!&#x3D;t)printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;by s1mple</span><br></pre></td></tr></table></figure>
<h2 id="H-Tautobots-and-Contradicticons"><a href="#H-Tautobots-and-Contradicticons" class="headerlink" title="H. Tautobots and Contradicticons"></a>H. Tautobots and Contradicticons</h2><blockquote>
<p><strong>Background:</strong><br>The planet Logotron is inhabited by two types of robots – the Tautobots and the Contradicticons. The Tautobots are programmed to always tell the truth, while the Contradicticons must always lie. Unfortunately, there is no simple way for outsiders to tell them apart, which often causes problems.<br><img src= "/img/loading.gif" data-src="https://res.jisuanke.com/img/upload/fe26db19b94b3b6b1413256fe2b9981486afa08c.png" alt=""><br><strong>The Problem:</strong><br>You are given a set of statements made by a group of robots. Every robot knows the type of every other robot, as well as itself. Each statement consists of an author (the robot that made the statement), a subject (the robot the statement is about), and the type of the subject (Tautobot or Contradicticon). For example, “Robot 5 says that Robot 2 is a Tautobot” is a valid statement. Note that if Robot 5 is a Contradicticon, then Robot 2 must also be a Contradicticon, since Robot 5 lied.<br>Given M statements made by N robots, you must find the number of distinct ways to assign a type to each robot, consistent with the statements. Two assignments are considered to be different if at least one robot is a Tautobot in one and a Contradicticon in the other.<br><strong>The Input:</strong><br>The first input line contains a positive integer T, indicating the number of test cases to be processed. This will be followed by T test cases.<br>Each test case is formatted as follows. The first line consists of the numbers N and M (1 ≤ N ≤ 15, 0 ≤ M ≤ 100). This is followed by M lines, each of which represents a statement by one of the robots. A statement is formatted as “A S X”. Here A and S are integers between 1 and N (inclusive) representing the author of the statement and its subject respectively (assume that A and S will be different robots). X will be one of the characters ‘T’ (for Tautobot) or ‘C’ (for Contradicticon).<br>Assume that a robot will not contradict itself (making a statement and then making the opposite of that statement) but different robots may contradict each other (in that case, there is no possible answer, i.e., zero assignments). Also assume that we will not have the same statement repeatedby a robot several times, i.e., no two input statements will be completely identical.<br><strong>The Output:</strong><br>For each test case, output a single line, formatted as: “Case #t:”, where t is the test case number (starting from 1), a single space, and then the number of distinct assignments that can be made for that case. Follow the format illustrated in Sample Output.<br><strong>样例输入</strong><br>3<br>3 2<br>1 2 T<br>2 3 C<br>4 2<br>1 2 T<br>2 3 C<br>2 0<br><strong>样例输出</strong><br>Case #1: 2<br>Case #2: 4<br>Case #3: 4  </p>
</blockquote>
<p><strong>题意</strong>：有两种机器人，一种必说真话，一种必说假话，给出多条描述，每条描述的信息有说话的机器人编号、评论的机器人编号、评论该机器人说的是真话还是假话，即：“A说B是T（C）”，问这些机器人的类型排列有多少种可能。<br><strong>题解</strong>：我们发现机器人的个数最多是15，很小，且有：  </p>
<blockquote>
<p><strong>100*2^15=3276800</strong>  </p>
</blockquote>
<p>那么考虑暴力枚举出所有真假类型的排列，然后逐条判断评论是否成立。<br>这里我想到了一种较简单的判断单条评论是否成立的性质，我们发现，假设该种排列成立，如类型为T，则评论者与被评论者类型相同，否则相反。<br>假设第i个机器人的类型为a[i]（a[i]=0,1），评论类型为w[j]，T时为0，C时为1，则有：  </p>
<blockquote>
<p><strong>a[i]^a[j]==w[k]</strong>  </p>
</blockquote>
<p>否则不成立。<br><strong>代码</strong>：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int t,n,m,s[105],e[105],w[105];</span><br><span class="line">char tmp;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	for(int p&#x3D;1;p&lt;&#x3D;t;++p)&#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;m;++i)&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;s[i],&amp;e[i]);</span><br><span class="line">			cin&gt;&gt;tmp;</span><br><span class="line">			if(tmp&#x3D;&#x3D;&#39;T&#39;)w[i]&#x3D;0;</span><br><span class="line">			else w[i]&#x3D;1;</span><br><span class="line">			--s[i],--e[i];</span><br><span class="line">		&#125;</span><br><span class="line">		int ans(0);</span><br><span class="line">		for(int i&#x3D;0;i&lt;(1&lt;&lt;n);++i)&#123;</span><br><span class="line">			bool flg(true);</span><br><span class="line">			for(int j&#x3D;1;j&lt;&#x3D;m;++j)&#123;</span><br><span class="line">				int x((i&gt;&gt;s[j])&amp;1),y((i&gt;&gt;e[j])&amp;1);</span><br><span class="line">				if((x^y)!&#x3D;w[j])&#123;</span><br><span class="line">					flg&#x3D;false;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(flg)++ans;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Case #%d: %d\n&quot;,p,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;by s1mple</span><br></pre></td></tr></table></figure>
<h2 id="I-A-Constant-Struggle"><a href="#I-A-Constant-Struggle" class="headerlink" title="I. A Constant Struggle"></a>I. A Constant Struggle</h2><blockquote>
<p><strong>Background:</strong><br>Your math teacher Xavier Guha has given your class an extra credit assignment to work on. The problem he gives is as follows: Given a linear equation of the form<br><strong>c1x1+c2x2+c3x3+c4x4+c5x5+c6x6+c7x7+c8x8=N</strong><br>with c1,…,c8, N given, he asks you to give the unique solution x (a vector of length 8) to the equation, where each xi is a non-negative integer. Of course, being a clever student, you realize that depending on the values of c and N, there may be no solution or there may be several solutions. After class, you approach him and inform him of the mistake, but he is stubborn and will not have any of your nonsense.<br>Having taken several programming classes from his brother, you decide to prove your teacher wrong by writing a program to determine how many solutions the equation has.<br><strong>The Problem:</strong><br>Given c1,…,c8 and N, determine how many unique solutions the equation has. Two solutions p and q are considered unique (different) if there exists some i for which pi≠qi. Since you may get this assignment again in the future, your program should be able to solve several instances of the equation.<br><strong>The Input:</strong><br>Input will begin with a positive integer T denoting the number of equations to solve. This will be followed by T lines, each containing an instance of the equation to solve. Each instance will be described by 9 space separated positive integers, all ≤ 100. The first 8 numbers represent c1,…,c8, and the 9th number represents N.<br><strong>The Output:</strong><br>For each equation, output a single line “Equation #E: S” where E is the equation number beginning with 1 and S is the number of unique solutions to the equation. It is guaranteed that the value of S will fit in a 64-bit signed integer.<br><strong>样例输入</strong><br>5<br>1 1 1 1 1 1 1 1 1<br>1 2 3 4 5 6 7 8 9<br>2 4 6 8 10 12 14 16 29<br>2 4 6 8 10 12 14 17 17<br>1 1 1 1 1 1 1 1 100<br><strong>样例输出</strong><br>Equation #1: 8<br>Equation #2: 29<br>Equation #3: 0<br>Equation #4: 1<br>Equation #5: 26075972546  </p>
</blockquote>
<p><strong>题意</strong>：给出一个八元一次方程的八个系数和常数项，求不同非负整数解的个数。<br><strong>题解</strong>：由于是非负整数解，我们可以想到，这类似于一个背包问题，有八种物品，每个物品的体积为ci，有无限个，当然，可以一个都不拿（该未知数解为0），背包的体积为N，问把背包刚好装满的方案数。<br>设f[i]为装到i体积的方案数，则有：  </p>
<blockquote>
<p><strong>f[i]=sigma(f[i-c[j]])</strong>  </p>
</blockquote>
<p><strong>代码</strong>：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define L long long</span><br><span class="line">L f[105];</span><br><span class="line">int a[10],n,t;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	for(int p&#x3D;1;p&lt;&#x3D;t;++p)&#123;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;8;++i)</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		memset(f,0,sizeof(f));</span><br><span class="line">		f[0]&#x3D;1;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;8;++i)</span><br><span class="line">			for(int j&#x3D;a[i];j&lt;&#x3D;n;++j)</span><br><span class="line">				f[j]+&#x3D;f[j-a[i]];</span><br><span class="line">		printf(&quot;Equation #%d: %lld\n&quot;,p,f[n]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;by s1mple</span><br></pre></td></tr></table></figure>
<h2 id="J-Polygon-Restoration"><a href="#J-Polygon-Restoration" class="headerlink" title="J. Polygon Restoration"></a>J. Polygon Restoration</h2><blockquote>
<p><strong>Background:</strong><br>A rectangular polygon is a closed figure with all vertices at points with integer coordinates in the XY-plane, and whose edges are all either horizontal or vertical. The vertices are all distinct, and no two edges intersect, except for neighboring edges intersecting at their common vertex. For the purposes of this problem, every horizontal edge will be adjacent to a vertical edge, and vice versa, so all angles are either 90 or 270 degrees.<br><img src= "/img/loading.gif" data-src="https://res.jisuanke.com/img/upload/b716a5b5d83ee9a2991193667d1eb5bbac307661.png" alt=""><br><strong>The Problem:</strong><br>Dr. O is an avid collector of polygons. He takes particular pride in his collection of pencil-rendered rectangular polygons from the early 19 th century. Unfortunately, some sneaky vandal has broken into his collection and erased all the edges, leaving only the vertices of each polygon. You have been called in to try to restore Dr. O’s collection to its former glory by redrawing the edges of the rectangular polygons.<br><strong>The Input:</strong><br>There will be multiple polygons in the input file. The first line of every polygon description will be an integer N (4 ≤ N ≤ 50), the number of vertices of the polygon. Each of the next N input lines will contain two integers, giving the coordinates of a vertex of a polygon in the form “X Y” (-10000 ≤ X, Y ≤ 10000). Note that these vertices are given in arbitrary order. All vertices will be distinct.<br>End of input will be indicated by a case with N = 0. This case should not be processed.<br><strong>The Output:</strong><br>For each test case, output a single line, formatted as: “Polygon #t:”, where t is the test case number (starting from 1), a single space, followed by the vertices of the polygon in counterclockwise order (with a single space separating vertices). Points should be referred to by their number in the order they were given in the input, the first input being vertex 1 (see Sample Output for clarification). The list must start from the vertex with minimum y-coordinate. If there are multiple points with minimum y-coordinate, use the one with minimum x-coordinate. It is guaranteed that a closed rectangular polygon can always be constructed from the given data.<br><strong>样例输入</strong><br>4<br>0 0<br>1 1<br>0 1<br>1 0<br>10<br>0 3<br>4 0<br>1 2<br>2 1<br>3 0<br>4 3<br>0 2<br>3 1<br>2 0<br>1 0<br>0<br><strong>样例输出</strong><br>Polygon #1: 1 4 2 3<br>Polygon #2: 10 9 4 8 5 2 6 1 7 3   </p>
</blockquote>
<p><strong>题意</strong>：给出多个点，它们是一个由矩形拼接成的多边形的顶点，即，每个内角均为90度或270度。要求按逆时针顺序输出多边形顶点序号。<br><strong>题解</strong>：仍然是暴力。<br>我们思考，对于一个这样的多边形，显然同一横（纵）坐标的直线上，必有偶数个顶点。<br>反证：假如有奇数个顶点，将该条直线上的点两两连边后，必剩下一个点，无法形成直角。<br>那么我们可以先按照坐标排序，然后先根据纵坐标连边，得到n/2条水平边，然后枚举不同纵坐标上的边，连垂直边并记录，就得到了多边形的所有边。<br>遍历得到答案时，只需要从左下角顶点出发，按照水平边-&gt;垂直边-&gt;…的顺序遍历，记录顶点即可。<br><strong>代码</strong>：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int id,x,y;</span><br><span class="line">	bool operator&lt;(const node &amp;a)const&#123;</span><br><span class="line">		if(y&#x3D;&#x3D;a.y)return x&lt;a.x;</span><br><span class="line">		return y&lt;a.y;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator&#x3D;&#x3D;(const node &amp;a)const&#123;</span><br><span class="line">		return id&#x3D;&#x3D;a.id&amp;&amp;x&#x3D;&#x3D;a.x&amp;&amp;y&#x3D;&#x3D;a.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[55],mp[55];</span><br><span class="line">struct edge&#123;</span><br><span class="line">	node s,e;</span><br><span class="line">&#125;stk[55][55];</span><br><span class="line">int t,n,ans[55],cnt,p,head[55],blsta[55],blpos[55];</span><br><span class="line">bool vis[55];</span><br><span class="line">int main()&#123;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">		if(!n)break;cnt&#x3D;0;++p;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">			a[i].id&#x3D;i;</span><br><span class="line">			vis[i]&#x3D;false;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a+1,a+n+1);</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;50;++i)</span><br><span class="line">			head[i]&#x3D;0;</span><br><span class="line">		int nowy(-20000),now(0);</span><br><span class="line">		for(int i&#x3D;1,j&#x3D;2;i&lt;&#x3D;n&amp;&amp;j&lt;&#x3D;n;i+&#x3D;2,j+&#x3D;2)&#123;</span><br><span class="line">			if(a[i].y!&#x3D;nowy)&#123;</span><br><span class="line">				nowy&#x3D;a[i].y;</span><br><span class="line">				++now;</span><br><span class="line">			&#125;</span><br><span class="line">			stk[now][++head[now]].s&#x3D;a[i];</span><br><span class="line">			stk[now][head[now]].e&#x3D;a[j];</span><br><span class="line">			blsta[a[i].id]&#x3D;blsta[a[j].id]&#x3D;now,blpos[a[i].id]&#x3D;blpos[a[j].id]&#x3D;head[now];</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;1;i&lt;now;++i)&#123;</span><br><span class="line">			for(int j&#x3D;1;j&lt;&#x3D;head[i];++j)&#123;</span><br><span class="line">				int s1(stk[i][j].s.id),e1(stk[i][j].e.id);</span><br><span class="line">				if(vis[s1]&amp;&amp;vis[e1])continue;</span><br><span class="line">				for(int k&#x3D;i+1;k&lt;&#x3D;now;++k)&#123;</span><br><span class="line">					for(int o&#x3D;1;o&lt;&#x3D;head[k];++o)&#123;</span><br><span class="line">						int s2(stk[k][o].s.id),e2(stk[k][o].e.id);</span><br><span class="line">						if(vis[s2]&amp;&amp;vis[e2])continue;</span><br><span class="line">						if(stk[i][j].s.x&#x3D;&#x3D;stk[k][o].e.x&amp;&amp;!vis[s1]&amp;&amp;!vis[e2])&#123;</span><br><span class="line">							vis[s1]&#x3D;vis[e2]&#x3D;true;</span><br><span class="line">							mp[s1]&#x3D;stk[k][o].e,mp[e2]&#x3D;stk[i][j].s;</span><br><span class="line">						&#125;</span><br><span class="line">						if(stk[i][j].e.x&#x3D;&#x3D;stk[k][o].s.x&amp;&amp;!vis[s2]&amp;&amp;!vis[e1])&#123;</span><br><span class="line">							vis[s2]&#x3D;vis[e1]&#x3D;true;</span><br><span class="line">							mp[s2]&#x3D;stk[i][j].e,mp[e1]&#x3D;stk[k][o].s;</span><br><span class="line">						&#125;</span><br><span class="line">						if(stk[i][j].s.x&#x3D;&#x3D;stk[k][o].s.x&amp;&amp;!vis[s1]&amp;&amp;!vis[s2])&#123;</span><br><span class="line">							vis[s1]&#x3D;vis[s2]&#x3D;true;</span><br><span class="line">							mp[s1]&#x3D;stk[k][o].s,mp[s2]&#x3D;stk[i][j].s;</span><br><span class="line">						&#125;</span><br><span class="line">						if(stk[i][j].e.x&#x3D;&#x3D;stk[k][o].e.x&amp;&amp;!vis[e1]&amp;&amp;!vis[e2])&#123;</span><br><span class="line">							vis[e1]&#x3D;vis[e2]&#x3D;true;</span><br><span class="line">							mp[e1]&#x3D;stk[k][o].e,mp[e2]&#x3D;stk[i][j].e;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int nowsta(1);node nowpos(a[1]);</span><br><span class="line">		ans[++cnt]&#x3D;a[1].id;</span><br><span class="line">		while(cnt&lt;n)&#123;</span><br><span class="line">			if(nowsta)&#123;</span><br><span class="line">				if(nowpos&#x3D;&#x3D;stk[blsta[nowpos.id]][blpos[nowpos.id]].s)</span><br><span class="line">					nowpos&#x3D;stk[blsta[nowpos.id]][blpos[nowpos.id]].e;</span><br><span class="line">				else</span><br><span class="line">					nowpos&#x3D;stk[blsta[nowpos.id]][blpos[nowpos.id]].s;</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">				nowpos&#x3D;mp[nowpos.id];</span><br><span class="line">			ans[++cnt]&#x3D;nowpos.id;</span><br><span class="line">			nowsta^&#x3D;1;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Polygon #%d:&quot;,p);</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;++i)</span><br><span class="line">			printf(&quot; %d&quot;,ans[i]);</span><br><span class="line">		printf(&quot; \n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;by s1mple</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这次比赛算是比较水的吧，还是不能懈怠，要继续训练提升，才能保持当前的状态。<br>南开NAVI up up！</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Nkus1mple</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/07/18/2020-07-18-%E8%AE%A1%E8%92%9C%E5%AE%A2%E6%AF%94%E8%B5%9B%EF%BC%88UCF-Local-Programming-Contest-2014-practice-%EF%BC%89%E6%AF%94%E8%B5%9B%E6%97%A5%E8%AE%B0/">http://yoursite.com/2020/07/18/2020-07-18-%E8%AE%A1%E8%92%9C%E5%AE%A2%E6%AF%94%E8%B5%9B%EF%BC%88UCF-Local-Programming-Contest-2014-practice-%EF%BC%89%E6%AF%94%E8%B5%9B%E6%97%A5%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">Nkus1mple's world</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/acm/">acm</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2020/07/14/Ua8Lyd.md.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/07/14/Read-Me/"><img class="next-cover" data-src="https://s1.ax1x.com/2020/07/14/Ua8Lyd.md.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Read Me</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Nkus1mple</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>